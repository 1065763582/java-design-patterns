# 状态对象模式(State Pattern)

行为型

允许一个对象在其内部状态改变时，改变他的行为

#### 适用场景

一个对象有多个状态，且行为不同

#### 优点

将不同状态的行为隔离，扩展新的状态容易

#### 缺点

1. 状态的转换在子类中，添加新的状态一定会修改某个原本的状态，不符合开闭原则
2. 一个状态一个类，状态多类就多

#### 类图

![类图](https://github.com/1065763582/java-design-patterns/blob/master/src/resources/img/stateClassDiagram.svg)

#### Q&A
1. 状态模式和策略模式的区别？

   两种模式都提供Context上下文类给应用层调用。

   策略模式：封装一系列平行且复杂多变的算法过程，这些算法各自独立且互不影响。上下文类的行为算法由应用层指定，用户需要知道存在哪些算法。

   状态模式：封装**一个**对象的**多个**状态的**不同**行为，这些状态会相互转换且影响类的行为。上下文类的行为由状态对象自动更换，用户需要知道有哪些操作，可以不需要知道有哪些状态。

2. 环境角色有两个不成文的约束：

   把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。

   环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。

3. 状态模式最大的缺陷在哪里？如何解决？

   最大的缺陷在于状态转换。代码里状态图是这样

   ![类图](https://github.com/1065763582/java-design-patterns/blob/master/src/resources/img/simpleState.svg)

   但是现实中大多是这样

   ![类图](https://github.com/1065763582/java-design-patterns/blob/master/src/resources/img/complexState.svg)

   这种复杂的状态转换代码耦合在了状态的行为内，若是行为的结果决定下一状态，可以将状态行为和状态转换分离；若是行为过程中某一些变量导致状态转换，那么就需要先收集这种导致状态转换的变量，在状态转换的函数中逐一判断这些变量来决定下一状态，这样也可以将状态行为和转换分离。