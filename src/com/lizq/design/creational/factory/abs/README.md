# 抽象工厂模式（Abstract Factory）

创建型

提供一个创建一些列相关或相互依赖对象的接口

#### 适用场景

1. 应用层不依赖于类实例如何被创建、实现等细节
2. 强调一系列相关的产品对象（属于同一产品族），一起使用创建对象需要大量重复的代码
3. 提供一个产品类库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现

#### 优点

1. 应用层只需要关心所需类的工厂，无须关心创建细节
2. 将一个系列的产品族统一到一起创建

#### 缺点

规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口

#### 类图

![类图](https://github.com/1065763582/java-design-patterns/blob/master/src/resources/img/abstractFactory.svg)

##### 与工厂方法模式的区别：产品等级结构 与 产品族

​        代码中定义了一个Student的接口，存在两个子类JavaStudent和PythonStudent，可以认为抽象的Student和它的两个子类构成了**产品等级结构**。新增一个抽象Teacher，存在两个子类JavaTeacher和PythonTeacher，同样可以认为抽象的Coder和它的两个子类构成了**产品等级结构**。每堂课，都存在老师和学生，定义一个课堂的工厂CourseFactory，可从具体的课程类（JavaCourseFactory/PythonCourseFactory）获取课程的老师和学生，注意此处JavaTeacher和JavaStudent是在同一个工厂获取的，他们被称为一个**产品族**。

 使用抽象工厂 方法，需要两个工厂类

* 增加一个产品等级结构，则需要新增一个工厂方法

* 增加一个产品族，则需要修改所有工厂方法，违反了开闭原则(抽象工厂的缺陷)

若新增若使用工厂方法模式，需要六个工厂类

* 增加一个产品族，则需要增加一个产品工厂方法
* 增加一个产品等级结构，则需要增加一个产品工厂方法
* 工厂方法模式会导致类变多

产品等级结构：产品等级结构即产品的继承结构

产品族：在抽象工厂模式中，产品族是指由**同一个**工厂生产的，位于不同产品等级结构中的一组产品。

工厂方法模式生产的是同一产品结构，抽象工厂生成的是同一产品族，抽象工厂解决了工厂方法模式类过多的问题，使用抽象工厂模式最好选取变化小的产品族。