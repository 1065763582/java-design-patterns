# 单例模式

创建型

确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

单例的四大原则：

1. 构造私有。
2. 以静态方法或者枚举返回实例。
3. 确保实例只有一个，尤其是多线程环境。
4. 确保反序列化和反射时不会重新构建对象。

#### 适用场景

如果一个类具有一下特点，可以考虑做成单例

1. 全局使用
2. 所有属性保持一致
3. 要求只有一个实例

#### 优点

1. 只有一个实例，节约内存
2. 可以全局访问
3. 避免频繁创建实例，提升效率

#### 缺点

不适用于有独立状态的类

#### 类图

![类图](https://github.com/1065763582/java-design-patterns/blob/master/src/resources/img/singleton.svg)

#### 懒汉模式

StaticInnerClassSingleton：利用静态内部类的静态属性，单例会被反射和序列化破坏。原理是利用类加载的机制保证线程安全。

LazySingleton：使用synchronized保证了方法的线程安全，但是并发性不好，同一时刻只能有一个现场能调用该方法。

LazyDoubleCheckLockSingleton：DCL双重锁检查，第一次判断 lazyDoubleCheckSingleton == null为了避免非必要加锁，当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。但是，由于jvm存在乱序执行功能，DCL也会出现线程不安全的情况。

#### 饿汉模式

HungrySingleton：类初始化过程中实例化单例类，单例会被反射和序列化破坏。原理是利用类加载的机制保证线程安全。

EnumInstance：利用枚举实例化，**最佳实践**，无法被反射和序列化破坏，原理是反射无法实例化枚举类，利用类加载的机制保证线程安全。

#### Q&A

1. 什么时候用单例模式，什么时候用静态类方法？

   评估这个类的方法是否可能被重写，如果不可能重写就用静态类。静态方法不能被重写，只能被隐藏，因此静态方法不具备多态。

2. 类什么时候初始化？

   * 创建类的实例，也就是new的方式

   * 访问某个类或接口的静态变量，或者对该静态变量赋值

   * 调用类的静态方法

   * 反射（如Class.forName(“”)）

   * 初始化某个类的子类，则其父类也会被初始化

   * Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类

3. 类加载的机制为什么能保证线程安全？

   《深入理解JAVA虚拟机》：虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞，需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。

4. DCL的lazyDoubleCheckSingleton为什么需要加volatile？

   new 一个实例分为三步：

   1.在堆内存开辟内存空间。

   2.在堆内存中实例化SingleTon里面的各个参数。

   3.把对象指向堆内存空间。

   在JVM中可能把第2步和第3步换一个顺序执行，假如一个线程先执行了第3步，这时另一个线程一看lazyDoubleCheckSingleton有地址了（地址空间内还是NULL），就立刻返回并调用其方法，但是前一个线程这时还没有实例化单例的参数，因此这个线程就会抛NPE，这就是**DCL失效问题**。在JDK1.6及以后，只需要加上volatile就能保证new的执行顺序，这样可以解决这个问题。